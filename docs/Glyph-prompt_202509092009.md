Prompt for Codex: Implement robust Japanese search (FTS + LIKE fallback)
========================================================================

Goal
----

Fix `/search` so that **Japanese queries hit reliably** even when FTS5 (`unicode61`) doesn’t tokenize CJK. Today, queries like `議会交際費` hit, but `交際費` or `行政視察` don’t. We want:

*   CJK queries to work with **prefix wildcards** on each term (e.g., `行政視察*`) and
*   a **LIKE fallback** (`%交際費%`) when FTS misses, then **merge & dedupe** results.

Context (current DB)
--------------------

*   SQLite FTS5 virtual table: `speeches_fts(speech_text) content='speeches' content_rowid='id' tokenize='unicode61'`
*   Main content: `speeches(id, minutes_id, agenda_item_id, speaker, role, speech_text)`
*   Join targets: `minutes(id, meeting_date TEXT, committee TEXT, title TEXT, ...)`
*   API response shape for each item (keep compatible): `{ id, meeting_date, committee, title, hit_count, snippet }`

Requirements
------------

1.  **CJK detection & query shaping**
    *   If `q` contains any CJK (`\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff`), split on whitespace, append `*` to each non-empty term, and join with `AND`.
        *   Example: `"高島平 再開発"` → `高島平* AND 再開発*`
    *   For non-CJK, keep the existing behavior (no forced `*`).
2.  **LIKE fallback**
    *   If the query contains CJK **or** the FTS returns 0 rows, also run:
        *   `speeches.speech_text LIKE :like_pattern` with `:like_pattern = f"%{q}%"`.
    *   Merge FTS and LIKE results with `UNION ALL` then `SELECT DISTINCT` to dedupe.
    *   Keep pagination & `order_by` behavior. If you must choose a single ordering, prefer `ORDER BY meeting_date DESC` for now.
3.  **SQL (parameterized) – reference**
    *   Use a single SQL that can include/exclude the LIKE CTE via conditional binding, or generate the variant you need:
    ```sql
    WITH f AS (
      SELECT s.id AS speech_id
      FROM speeches_fts
      JOIN speeches s ON speeches_fts.rowid = s.id
      WHERE speeches_fts MATCH :fts_query
    ),
    l AS (
      SELECT s.id AS speech_id
      FROM speeches s
      WHERE (:use_like = 1) AND s.speech_text LIKE :like_pattern ESCAPE '\'
    ),
    u AS (
      SELECT speech_id FROM f
      UNION ALL
      SELECT speech_id FROM l
    )
    SELECT DISTINCT
      m.id             AS id,
      m.meeting_date   AS meeting_date,
      m.committee      AS committee,
      m.title          AS title,
      -- crude hit_count: count how many sources contributed (1 or 2)
      1                AS hit_count,
      -- FTS snippet if available; else fallback to a short prefix
      COALESCE(
        highlight(speeches_fts, 0, '<em>', '</em>'),
        substr(sp.speech_text, 1, 80)
      )                AS snippet
    FROM u
    JOIN speeches sp           ON sp.id  = u.speech_id
    JOIN minutes  m            ON m.id   = sp.minutes_id
    LEFT JOIN speeches_fts ft  ON ft.rowid = sp.id
    ORDER BY m.meeting_date DESC
    LIMIT :limit OFFSET :offset;
    ```
    *   If `highlight()` returns empty when there’s no FTS path, that’s fine; we already fallback to `substr()`.
4.  **CJK detection helper (Python)**
    ```python
    import re
    _CJK_RE = re.compile(r'[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff]')
    def is_cjk_query(q: str) -> bool:
        return bool(_CJK_RE.search(q or ""))
    def to_fts_query(q: str, cjk: bool) -> str:
        if not q:
            return ""
        if not cjk:
            return q  # keep current behavior for non-CJK
        terms = [t for t in q.split() if t]
        if not terms:
            return q + "*"  # single wildcard as a last resort
        return " AND ".join(f"{t}*" for t in terms)
    ```
5.  **Endpoint changes (`/search`)**
    *   Pseudocode:
    ```python
    def search(q: str, limit: int = 10, offset: int = 0, order_by: str = "relevance"):
        cjk = is_cjk_query(q)
        fts_query = to_fts_query(q, cjk)
        like_pattern = f"%{q}%"
        use_like = 1 if cjk else 0
        rows = run_sql(SQL, {
            "fts_query": fts_query,
            "use_like": use_like,
            "like_pattern": like_pattern,
            "limit": limit,
            "offset": offset,
        })
        total = count_rows(rows)  # or separate COUNT query if needed
        items = [
            {
              "id": r["id"],
              "meeting_date": r["meeting_date"],
              "committee": r["committee"],
              "title": r["title"],
              "hit_count": r.get("hit_count", 1),
              "snippet": r["snippet"],
            } for r in rows
        ]
        return { "items": items, "total": total, "limit": limit, "offset": offset,
                 "page": offset // max(limit,1) + 1, "has_next": total > offset + len(items) }
    ```
    *   Ensure query params are **URL-decoded** and accept `q` containing CJK. Keep `Accept: application/json`.
6.  **Acceptance tests (pytest)**
    *   Prepare a temp SQLite DB with:
        *   `minutes`: rows for IDs 12 (`令和7年度　議会交際費`), 6 (`行政視察受入れのご案内`), 3（`議会報告会`）
        *   `speeches` with `speech_text` set to:
            *   `その他 令和7年度　議会交際費`
            *   `その他 行政視察受入れのご案内`
            *   `その他 議会報告会`
        *   `speeches_fts` configured as in production and rebuilt.
    *   Assertions:
        *   `GET /search?q=議会交際費` → total≥1, includes id=12
        *   `GET /search?q=交際費` → total≥1, includes id=12 (**LIKE fallback or wildcard makes it hit**)
        *   `GET /search?q=行政視察` → total≥1, includes id=6
        *   `GET /search?q=議会報告会` → total≥1, includes id=3
        *   `GET /search?q=test` → returns JSON `{items: [], total: 0, ...}` (no 400)
7.  **Notes**
    *   Keep SQL **parameterized** (no string interpolation in `MATCH`).
    *   If `highlight()` causes performance issues, keep it but cap snippet length to ~120 chars afterward.
    *   No schema change required.
    *   We intentionally **do not** reintroduce triggers for FTS; we rely on `rebuild` after batch loads, or add triggers later under `PRAGMA trusted_schema=ON` per-connection if needed.

Deliverables
------------

*   Code changes in the API layer implementing:
    *   `is_cjk_query`, `to_fts_query`
    *   Updated `/search` handler with FTS+LIKE union logic
*   Tests (`pytest`) covering the 4 assertions above
*   Brief doc update in README/DEVNOTES: “Japanese queries: wildcard + LIKE fallback”

Done when
---------

*   Manual checks:
    *   `GET /search?q=議会交際費` returns id=12
    *   `GET /search?q=交際費` returns id=12
    *   `GET /search?q=行政視察` returns id=6
    *   `GET /search?q=議会報告会` returns id=3
*   JSON is always returned (no `text/plain` errors), and URL-encoded CJK queries succeed

* * *

参考：直近の切り分け結果（現状の問題像の根拠）。スプリント3終了後確認



---
Powered by [ChatGPT Exporter](https://www.chatgptexporter.com)