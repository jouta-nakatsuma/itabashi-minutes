# スプリント3実装計画

**User:** Anonymous (sunpin32@yahoo.co.jp)  
**Created:** 9/8/2025 16:17:26  
**Updated:** 9/8/2025 17:53:38  
**Exported:** 9/8/2025 17:53:49  
**Link:** [https://chatgpt.com/g/g-p-68a2428917408191ab595311b37e4516-itabashi-minutes/c/68be82fe-e1d0-832c-aceb-435dd9a31485](https://chatgpt.com/g/g-p-68a2428917408191ab595311b37e4516-itabashi-minutes/c/68be82fe-e1d0-832c-aceb-435dd9a31485)  

## Response:
レビュー結果です。結論：**ほぼ要件どおりでOK／ただし“改行混入による構文エラー”があるので修正必須**。そのうえで、いくつか小さな改善提案を添えます。

必須修正（Blocking）
==============

Unified diff内にソフトラップ由来の改行が紛れています。現状のままだと **SyntaxError** や **SQLの識別子分割** になります。以下の4点は必ず直してください。

1.  `order_by` のデフォルト値

```py
- order_by: Literal["relevance", "date", "committee"] = Query(default="da
te"),
+ order_by: Literal["relevance", "date", "committee"] = Query(default="date"),
```

2.  文字列フォーマットに混入した改行（qありブランチの order\_clause）

```py
- order_clause = f"m.hits {order_dir}, mn.meeting_date DESC, mn.i
d DESC"
+ order_clause = f"m.hits {order_dir}, mn.meeting_date DESC, mn.id DESC"

- order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.me
eting_date DESC, mn.id DESC"
+ order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.meeting_date DESC, mn.id DESC"
```

3.  文字列フォーマットに混入した改行（qなしブランチの order\_clause）

```py
- order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.me
eting_date DESC, mn.id DESC"
+ order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.meeting_date DESC, mn.id DESC"
```

4.  `return SearchResponse(...)` の引数が途中改行で崩れている箇所  
    （`offset=off\nset` など）実体は以下のように1行ずつ素直に：

```py
return SearchResponse(
    items=items,
    total=total,
    limit=limit,
    offset=offset,
    page=page,
    has_next=has_next,
)
```

妥当性チェック（OK）
===========

*   `limit=10` へ変更（最大100）: ✅
*   `page`/`has_next` の算出: ✅
*   `order_by` / `order`（whitelist＋LiteralでOpenAPIも安全）: ✅
*   qあり：`matched` CTEで minutes単位に集約 → `hits` と `first_sp_id` を取得 → `snippet(sfts, -1, …)` で `<em>` ハイライト返却: ✅
*   qなし：先頭発話の `substr(...)` をスニペットに使用、`hit_count=0`: ✅
*   並び替えのフォールバック（qなしで `relevance` 指定時は date扱い、committeeはNOCASEソート）: ✅
*   SQLインジェクション対策：`order_clause` は `Literal` に基づく分岐でのみ生成、他はプレースホルダ param。: ✅

追加の改善（Nice to have）
===================

1.  **OpenAPIの例**  
    `SearchResponse` に `model_config` の `json_schema_extra={"example": {...}}` を付け、`page`/`has_next` を含むレスポンス例を掲載すると `/docs` が親切になります。
2.  **`committee` フィルタの大文字小文字**  
    検索時に `COLLATE NOCASE` をフィルタにも適用するか、格納時に正規化しておくとUI操作が楽になります（今は完全一致前提）。
3.  **関連度の将来拡張**  
    現状の `m.hits` 降順はOK。後続タスクで `bm25()` が使える構成（FTS5 オプション）なら `ORDER BY bm25(sfts)` への切替を別PRで。
4.  **`offset` 上限**  
    `le=10000` は十分ですが、Nightlyでデータが増える将来を見据え、`max_offset` の設定や「最大ページ数」をAPIで返すのもアリです（UI実装が楽）。
5.  **インデックス確認**  
    `minutes(meeting_date)`, `minutes(committee COLLATE NOCASE)`, `speeches(minutes_id)` あたりの索引があると `COUNT` / `ORDER BY` が安定します。

テスト観点（追加で見ると良い）
===============

*   `order_by=relevance` かつ `q` 未指定 → **dateフォールバック**になっていること。
*   `limit=0` の防御（現状 `ge=1` なのでOK）
*   `has_next` の境界（`total - len(items) == offset` で False）

* * *

ミニパッチ（上記 Blocking の修正だけ適用）
--------------------------

```diff
-        order_by: Literal["relevance", "date", "committee"] = Query(default="da
-te"),
+        order_by: Literal["relevance", "date", "committee"] = Query(default="date"),

@@
-            if order_by == "relevance":
-                order_clause = f"m.hits {order_dir}, mn.meeting_date DESC, mn.i
-d DESC"
-            elif order_by == "committee":
-                order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.me
-eting_date DESC, mn.id DESC"
+            if order_by == "relevance":
+                order_clause = f"m.hits {order_dir}, mn.meeting_date DESC, mn.id DESC"
+            elif order_by == "committee":
+                order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.meeting_date DESC, mn.id DESC"
             else:  # date
                 order_clause = f"mn.meeting_date {order_dir}, mn.id DESC"

@@
-            if order_by == "committee":
-                order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.me
-eting_date DESC, mn.id DESC"
+            if order_by == "committee":
+                order_clause = f"mn.committee COLLATE NOCASE {order_dir}, mn.meeting_date DESC, mn.id DESC"
             else:
                 order_clause = f"mn.meeting_date {order_dir}, mn.id DESC"

@@
-        return SearchResponse(items=items, total=total, limit=limit, offset=off
-set)
+        page = (offset // limit) + 1 if limit > 0 else 1
+        has_next = (offset + len(items)) < total
+        return SearchResponse(
+            items=items,
+            total=total,
+            limit=limit,
+            offset=offset,
+            page=page,
+            has_next=has_next,
+        )
```

* * *

必要なら、この修正込みの完全diffを再生成するコメントを整えて返します。このまま **「approve（修正条件付き）」** で返して進めましょうか？



---
Powered by [ChatGPT Exporter](https://www.chatgptexporter.com)